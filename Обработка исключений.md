Синтаксис раздела обработки ошибок (исключений)
```sql
EXCEPTION
  WHEN {expception_name_1 | error_code_1} THEN 
    {operators_exception_1}
  WHEN {expception_name_N | error_code_N} THEN 
    {operators_exception_N}
  [WHEN OTHERS THEN {operators_exception_others}]
```

Раздел обработки ошибок располагается после исполняемого раздела перед оператором конца блока `END`. При этом для каждого исключения указываются определенные действия, которые должны выполняться при возникновении этого исключения.

Каждая ошибка имеет имя и код ошибки. При обработке ошибки нужно указать ее имя или код. Для указания кода ошибки используется конструкция: `sqlstate '{error_code}'`.

В простейшем случае операторы обработки исключений могут представлять собой операторы вывода сообщений, которые в понятной для пользователя форме сообщают причину возникшей ошибки и содержат рекомендации о способах ее устранения.

Для инициализирования и вывода сообщений об ошибках используется команда `RAISE`  , которая имеет две основные формы
```sql
RAISE [{level}] = '{format}' [,{parameters}] [USING {parameter} = {value}];

RAISE [{level}] {exception_name} [USING list{parameter} = {value}]];
```

Первая форма используется для вывода сообщений, и команда будет обязательно выполнена. Параметр `level` для этой формы, как правило, имеет значение `NOTICE`.

Вторая форма команды будет выполнена только для заданного исключения. Параметр `level` для этой формы, как правило, имеет значение `EXCEPTION`. Результаты выполнения команды `RAISE` с этим значением уровня является прерывание работы программы.

Здесь `level` задает уровень важности ошибок. Возможные значения: `DEBUG`, `LOG`, `INFO`, `NOTICE`, `WARNING` и `EXCEPTION`. По умолчанию используется `EXCEPTION`. А `format` -- определяет текст сообщения. Представляет собой текстовую константу, содержит текст и символы `%`. Количество символов `%` должно соответствовать количеству параметров. Параметр может быть текстовый константой или переменной, значение которой будет выведено в сообщении. `USING` -- позволяет добавить дополнительную информацию к сообщению об ошибке. Например, `USING ERRCODE = 50001` устанавливает код ошибки.

Невозможно, а в ряде случаев нецелесообразно, учитывать все возможные ошибки, которые могут возникнуть в процессе выполнения программы, поэтому раздел обработки исключений может содержать операторы обработки исключений, которые не были обработаны другими обработчиками. Эти операторы располагаются в конце раздела обработки исключений, после служебных слов `WHEN OTHERS THEN`.

В обработчике исключений можно использовать специальные переменные:
- `SQLSTATE` -- содержит код ошибки,
- `SQLERRM` -- содержит сообщение об ошибке.

Можно получить дополнительную информацию об ошибке, используя команду:
```sql
GET STACKED DIAGNOSTICS {var} := {elem};
```
Здесь `var` -- объявленная переменная, имеющая тип `text`.

Чтобы перехватить ошибку ограничения первичного ключа (`UNIQUE_VIOLATION`; заказ с указанным номером уже существует), нужно добавить блок `EXCEPTION`
```sql
DO $$
DECLARE
  v_id INTEGER;
BEGIN
  RAISE NOTICE 'Results: ';
  INSERT INTO orders(order_id, customer_id, salesman_id, order_date, status)
  VALUES (82, 48, 175, DEFAULT, DEFAULT);
  RAISE NOTICE 'Done.';
EXCEPTION
  WHEN UNIQUE_VIOLATION THEN -- ошибка ограничения первичного ключа
    SELECT MAX(order_id) INTO v_id 
    FROM orders;
  v_id := v_id + 1;
  INSERT INTO orders(order_id, customer_id, salesman_id, order_date, status)
  VALUES (v_id, 48, 175, DEFAULT, DEFAULT);
  RAISE NOTICE 'Done. id = %', v_id;
END $$;
```

Рассмотрим пример объявления и обработки исключения для ошибки 23503. Эта ошибка связана с нарушением целостности данных и возникает в том случае, если из главной (родительской) таблицы совершается попытка удалить строку, с которой связаны строки подчиненной (дочерней) таблицы. Эта ошибка не возникает, если при определении внешнего ключа указано правило поддержания целостности `ON DELETE CASCASDE` -- каскадное удаление строк подчиненной таблицы. В этом случае при удалении строки главной таблицы автоматически удаляются все строки подчиненной таблицы, связанные с удаляемой строкой [[Литература#^af0aa6]]<c. 370>.
```sql
DO $$
DECLARE
  err_msg text;
BEGIN
  INSERT INTO orders(order_id, customer_id, salesman_id)
  VALUES (133, 18, 215);
EXCEPTION
  WHEN SQLSTATE '23503' THEN
    GET STACKED DIAGNOSTICS err_msg = MESSAGE_TEXT;
    RAISE NOTICE 'Error! %', err_msg;
    INSERT INTO orders(order_id, customer_id, salesman_id)
    VALUES (133, 18, NULL);
END $$;
```

Как уже упоминалось, невозможно предусмотреть и обработать все возможные ошибки. Однако раздел обработки исключений может содержать обработчик `OTHERS`, который содержит операторы обработки исключительных ситуаций, не обработанных другими обработчиками этого раздела
```sql
DO $$
DECLARE
  err_msg text;
BEGIN
  INSERT INTO orders(order_id, customer_id, salesman_id)
  VALUES (134, 45, 'Pending');
EXCEPTION
  WHEN SQLSTATE '23503' THEN
    GET STACKED DIAGNOSTICS err_msg = MESSAGE_TEXT;
    RAISE NOTICE 'Error! %', err_msg;
    INSERT INTO orders(order_id, customer_id, salesman_id)
    VALUES (134, 45, NULL);
  WHEN OTHERS THEN
    RAISE NOTICE 'Error code: %', SQLSTATE;
    RAISE NOTICE 'Message of error: %', SQLERRM;
END $$;
```

Здесь для определения кода ошибки и причины ее возникнования используются специальные необъявленные переменные `SQLSTATE` и `SQLERRM`.

