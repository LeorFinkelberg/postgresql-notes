Процедуры используются в тех случаях, когда нужно внести изменения в данные. Задача функций состоит в том, чтобы выполнять обработку данных и вернуть в вызывающую среду результат этой обработки. Результат может представлять собой как скалярное значение, так и таблицу.

Движок PL/pgSQL может находиться на стороне клиента, а исполнитель запросов SQL всегда находится на сервере. Частое переключение контекста приводит к росту сетевого трафика, а также к существенному увеличению времени обработки данных. При разработке программ PL/pgSQL следует использовать средства, которые позволяют сократить количество переключений контекста [[Литература#^af0aa6]]<c. 255>.

Основным значением PL/pgSQL является разработка хранимых процедур, функций и триггеров.

### Структура блока PL/pgSQL

Все программы PL/pgSQL состоят из блоков. Блок объединяет операторы, предназначенные для решения определенной задачи. Одна программа может содержать несколько блоков, которые могут располагаться последовательно один за другим или быть вложенными. Блоки могут быть анонимными или именованными. Анонимные блоки не имеют имени, они не могут быть сохранены в базе данных, и на них нельзя ссылаться.

_Именованные блоки_ используются при создании _подпрограмм_. Эти блоки представляют собой процедуры и функции, которые храняться в базе данных и которые можно вызывать по имени.

В общем виде структура 
```sql
[DECLARE]
{Раздел объявлений}
BEGIN
{Выполняемый раздел}
[EXCEPTION]
{Раздел обработки ошибок}
END;
```

_Раздел объявлений_ может содержать определение типов, переменных, курсоров, локальных подпрограмм и исключений, определяемых пользователем.

_Выполняемый раздел_ начинается с ключевого слова `BEGIN` и заканчивается ключевым словом `END`. Может содержать операторы присваивания, управления и операторы SQL.

_Раздел обработки ошибок_ начинается с ключевого слова `EXCEPTION` и определяет действия, которые должны выполняться при возникновании ошибок в выполняемом разделе.

Обязательным является только выполняемый раздел. Он должен содержать хотя бы один выполняемый оператор.

В PL/pgSQL можно использовать два вида комментариев: комментарии до конца строки, который начинается с двойного тире `--`, и блочный комментарий `/*...*/`

Для вывода результатов на экран можно использовать `RAISE NOTICE`
```sql
RAISE NOTICE '{text} % [%]', {var1}[{var2}];
```

### Анонимные блоки

Анонимный блок является приложением, взаимодействующим с базой данных. Свойства анонимных блоков:
- не имеют имени,
- не хранятся в базе данных,
- компилируются при каждом выполнении,
- передаются PL/pgSQL Engine для выполнения в реальном времени,
- не могут быть вызваны.

Примеры анонимных блоков
```sql
DO $$
DECLARE
  a real := -1;
  b real := -1;
  c real := -6;
  d real;
  x1 real;
  x2 real;
  text_var1 text;
  text_var2 text;
BEGIN
  d := SQRT(b * b - 4 * a * c);
  x1 := - (b + d) / (2 * a);
  x2 := (-b + d) / (2 * a);
  RAISE NOTICE 'Results: '; -- как в Python print("Results: ")
  RAISE NOTICE 'Roots of a * x^2 + b * x + c = 0';
  RAISE NOTICE 'x1 = %', x1;
  RAISE NOTICE 'x2 = %', x2;
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS
    text_var1 = MESSAGE_TEXT, 
	text_var2 = RETURNED_SQLSTATE;
RAISE NOTICE 'Error = %', text_var1;
RAISE NOTICE 'Code of error = %', text_var2;
END $$;
```

Если выражение `b * b - 4 * a * c` окажется отрицательным, то извлечь корень не удастся. Там, где это возможно, следует использовать процедурные средства предотвращения ошибок, а не обработку исключений.
```sql
DO $$
DECLARE
  a real := -1;
  b real := -1;
  c real := -6;
  d real;
  x1 real;
  x2 real;
BEGIN
	RAISE NOTICE 'Results: '; -- как в Python print("Results: ")
	
	IF (b * b - 4 * a * c) >= 0 THEN
	  d := SQRT(b * b - 4 * a * c);
	  x1 := - (b + d) / (2 * a);
	  x2 := (-b + d) / (2 * a);
	  RAISE NOTICE 'Roots: ';
	ELSE
	  RAISE NOTICE 'There are no valid roots ...';
	END IF;
END $$;
-- Results:
-- There are no valid roots ...
```

### Переменные, константы и типы данных

Кроме переменных, можно объявить и использовать константы. В отличие от переменных, значение констант нельзя изменить. Имена переменных нечувствительны к регистру.

Если при объявлении указано служебное слово `CONSTANT`, то этот идентификатор является константой, ему нужно при объявлении присвоить значение, которое нельзя будет изменять.

В коде PL/pgSQL можно использовать типы данных, определяемых пользователями, и составные типы данных.

Если объявить переменные, но не присвоить им значения, то они будут иметь значение `NULL`. Любое арифметическое выражение будет иметь значение `NULL`, если хотя бы один элемент этого выражения будет иметь значение `NULL`.

Использование переменных символьного типа
```sql
DO $$
DECLARE
  first_name varchar(10);
  last_name varchar(10);
BEGIN
  first_name = 'Leor';
  last_name = 'Finkelberg';
  
  RAISE NOTICE 'Full name: %', CONCAT(first_name, ' ', last_name);
END $$;
```

### Неявное объявление типа переменной

Можно объявить переменную, тип которой совпадает либо с типом ранее объявленной переменной, либо с типом столбца таблицы.
```sql
{var_name} {base_var}%TYPE;
{var_name} {table.col}%TYPE;
```

Использование атрибута `%TYPE` позволяет избежать ошибок, вызыванных несоответствием типа или точности данных. Не нужно изменять объявление переменной, если изменится определение переменной или столбца таблицы, значение которых присваивается переменной.

Если для базовой переменной задано ограничение `NOT NULL`, то переменной, которой будет присваиваться тип базовой переменной, нужно при объявлении обязательно присваивать значение. Но если переменной присваивается _тип столбца таблицы_, для которого задано ограничение `NOT NULL`, присваивать значение переменной при объявлении необязательно, так как это ограничение на переменную не переносится.
```sql
DO $$
DECLARE
  v_emp_id employees.employee_id%TYPE := 106;
  v_old_sal employees.salary%TYPE;
  v_new_sal v_old_sal%TYPE;
BEGIN
  SELECT salary INTO v_old_sal
  FROM employees
  WHERE employee_id = v_emp_id;

  UPDATE employees
  SET salary = 1.1 * salary
  WHERE employee_id = v_emp_id;

  SELECT salary INTO v_new_sal
  FROM employees
  WHERE employee_id = v_emp_id;

  RAISE NOTICE 'Results: ';
  RAISE NOTICE 'employee_id = %', v_emp_id;
  RAISE NOTICE 'Start salary = %', v_old_sal;
  RAISE NOTICE 'New salary = %', v_new_sal;
END $$;
```

Можно создать переменную, содержащую несколько полей, структура которой совпадает со структурой определенной таблицы
```sql
{var_name} {table_name}%ROWTYPE;
```

Обращение к определенному полю такой переменной имеет следующий вид
```sql
{var_name}.{field_name}
```

Переменная типа `ROWTYPE` похожа на структуру языка Си или именованный кортеж языка Python
```sql
DO $$
DECLARE
  -- {table_name}%ROWTYPE - это что-то вроде именованного кортежа в Python
  -- но присваивать значения всем полям необязательно!
  row1 customers%ROWTYPE; 
  row2 customers%ROWTYPE;
  v_sum_credit_limit NUMERIC(10, 2);
BEGIN
  row1.c_name := 'Ivan Petrov';
  row1.credit_limit := 200000;
  row2.c_name := 'Sergey Ivanov';
  row2.credit_limit := 300000;
  v_sum_credit_limit := row1.credit_limit + row2.credit_limit;
  RAISE NOTICE 'Rsult: ';
  RAISE NOTICE 'Employee name 1: %', row1.c_name;
  RAISE NOTICE 'Employee name 2: %', row2.c_name;
  RAISE NOTICE 'Credit limit 1: %', row1.credit_limit;
  RAISE NOTICE 'Credit limit 2: %', row1.credit_limit;
  RAISE NOTICE 'Sum credit limit: %', v_sum_credit_limit;
END $$;
```

### Область действия переменных

Если блок содержит вложенные блоки, то переменные, объявленные во внешнем блоке, можно использовать во вложенных блоках. Если во _внешнем_ и _вложенном блоке_ объявлены переменные, имеющие _одинаковое имя_, то это ==разные переменные==. Значения переменной, объявленной во внешнем блоке, не передается во внутренний блок, а изменение значения переменной во внутреннем блоке не изменяет значение, которое она имела во внешнем блоке [[Литература#^af0aa6]]<c. 267>.

Во внутреннем блоке можно использовать одноименные переменные из внешнего блока. Для этого необходимо установить метки блоков, которые имеют следующий синтаксис `<<{label_of_block}>>`. Ссылка во внутреннем блоке на переменную из внешнего блока имеет следующий вид: `{label_of_block}.{var_name}` [[Литература#^af0aa6]]<c. 268>.

