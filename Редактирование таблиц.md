В процессе работы с базой данных возникает необходимость вносить изменения в существующие таблицы. Такими изменениями могут быть:
- добавление или удаление столбцов,
- изменение имени, типа и значения по умолчанию,
- добавление и удаление ограничений,
- удаление таблиц.

Для осуществления этих операций служит команда
```sql
ALTER TABLE {table_name}
{code_edit}
```

### Добавление и удаление столбцов

Для добавления нового столбца используется команда
```sql
ALTER TABLE {table_name} ADD COLUMN
({col_name} {col_type});
```

Пример
```sql
ALTER TABLE customers ADD COLUMN rating int4;
```

Для удаления существующих столбцов служит команда
```sql
ALTER TABLE {table_name} DROP COLUMN {col_name};
```

При применении этого оператора следует соблюдать следующие правила:
- одним оператором можно удалить только один столбец,
- нельзя удалить все столбцы в таблице.

### Изменение столбцов

Можно изменить имя столбцы, используя команду
```sql
ALTER TABLE {table_name}
RENAME COLUMN {old_name} TO {new_name};
```

Пример
```sql
ALTER TABLE customers
RENAME COLUMN rating TO rating_c;
```

Для изменения типа служит команда
```sql
ALTER TABLE {table_name}
ALTER COLUMN {table_name} TYPE {new_type};
```

Пример
```sql
ALTER TABLE customers
ALTER COLUMN rating_c TYPE smallint;
```

При использовании этого оператора следует соблюдать следующие правила: увеличивать число разрядов, числового столбца и ширину строки символов можно всегда, а уменьшать можно только до наибольшего значения, содержащегося в столбце.

Изменить значение по умолчанию можно командой
```sql
ALTER TABLE {table_name}
ALTER COLUMN {col_name} SET DEFAULT {value};
```

Пример
```sql
ALTER TABLE customers
ALTER COLUMN rating_c SET DEFAULT 1;
```

Изменение значения по умолчанию столбца влияет только на строки, которые будут добавлены позже, имеющиеся значения изменены не будут.

### Изменение ограничений

Добавление ограничения
```sql
ALTER TABLE {table_name} ADD CONSTRAINT {constr_name} {const_text};
```

Пример
```sql
ALTER TABLE customers ADD CONSTRAINT customers_rating_ch CHECK((rating_c > 0) AND (rating_c <= 5));
```

Удаление ограничения
```sql
ALTER TABLE {table_name}
DROP CONSTRAINT {const_name};
```

### Удаление таблицы

Для удаления таблицы используется команда `DROP TABLE`. В результате выполнения этой команды из таблицы удаляются все данные, и описание таблицы удаляются из словаря данных.

Если удаляемая таблица связана с другими таблицами, в которых определены внешние ключи, ссылающиеся на столбцы удаляемой таблицы, то эта команда не будет выполнена. 

Для удаления таблиц с ограничениями целостности следует использовать команду
```sql
DROP TABLE {table_name} CASCADE;
```

При выполнении этой команды в связанных таблицах удаляются ограничения внешнего ключа.
### Получение информации о таблицах базы данных

База данных PostgreSQL предоставляет два вида набора таблиц и представлений, которые содержат метаинформацию об объектах базы данных:
- Системный каталог (`pg_catalog`) - представляет собой набор таблиц и представлений с описанием всех объектов СУБД.
- Информационная схема (`information_schema`) -- предназначена для представления метаданных в соответствии со стандартами SQL, но не отражает ряд специфических особенностей PostgreSQL.

### Представления

_Представлением_ называют сохраненный запрос, которому присваивается имя. Это имя может использоваться в качестве источника данных в других запросах.

Имя представления не должно совпадать с именем таблиц базы данных. Если в качестве источника данных указано имя представления, то СУБД выполняет содержащийся в нем запрос и возвращает результат его выполнения.

По логике использования _представления_ имеют много общего с _подпрограммами_. Если какую-либо обработку данных приходится использовать _многократно_ в различных запросах, то целесообразно реализовать ее в виде представления, и указывать его имя там, где это необходимо. Имена представлений можно указывать там, где можно указывать имена таблиц [[Литература#^af0aa6]]<c. 235>. 

Для создания представлений используется оператор `CREATE VIEW`
```sql
CREATE [OR REPLACE] [TEMP] [RECURSIVE] VIEW {view_name} [{list_of_cols}]
AS {query_text}
[WITH [CASCADE | LOCAL] CHECK OPTION]
```

Параметры этого оператора:
- `OR REPLACE`: если этот оператор указан, то при повторном выполнении ранее созданное представление будет перезаписано,
- `TEMP`: при наличии этого параметра будет создано временное представление. Временные представления автоматически удаляются в конце текущего сеанса. Существующие постоянные представления с тем же именем не видны текущему сеансу, пока существует временное представление,
- `RECURSIVE`: будет создано рекурсивное представление,
- `WITH [CASCADE | LOCAL] CHECK OPTION`: этот параметр управляет поведением представлений, используемых для изменения данных. Если этот параметр указан, то при выполнении операторов `INSERT` и `UPDATE` будет осуществляться проверка: новые строки должны удовлетворять условиям, заданным в представлении. Если эти условия не будут выполнены хотя бы для одной строки, то изменение будет отменено для всех строк.

Представления позволяют:
- упростить создание сложных запросов, которые следует разделить на части, и реализовать каждую часть в виде представления,
- ограничить доступ пользователей к данным, создавая представления, которые содержат только те столбцы, доступ к которым разрешен.

Есть два типа представлений: простые и сложные. Простое представление -- это представление, которое использует данные только из одной таблицы, не содержит фунцкий или групп данных. Сложное представление -- это представление, которое использует данные из нескольких таблиц или содержит функции или группы данных.

В операторах изменения данных `INSERT`, `UPDATE`, `MERGE`, `DELETE` можно использовать только простые представления.

Создание представления, которое содержит данные о сотрудниках, зарплата которых больше 8000, но меньше 10000
```sql
CREATE OR REPLACE VIEW view_salary_10000 AS 
SELECT
  department_id,
  employee_id,
  first_name,
  last_name,
  salary
FROM employees
WHERE salary BETWEEN 8000 AND 10000
WITH CHECK OPTION; -- проверяется условие, описанное в WHERE
```

Создание сложного представления, которое возвращает `order_id` , `order_date` и `summa`
```sql
CREATE OR REPLACE VIEW order_summa(order_id, order_date, summa)
AS
SELECT
  order_id,
  order_date,
  SUM(quantity * unit_price)
FROM orders JOIN order_items USING (order_id)
GROUP BY 1, 2;
```

Вывести данные о клиентах, у которых средняя сумма заказа превышает общую среднюю сумму одного заказа
```sql
-- создать представление, которое выводит номера клиентов и среднюю сумму их заказов
CREATE OR REPLACE VIEW avg_c AS  -- VIEW-1
SELECT
  customer_id,
  AVG(quantity * unit_price) AS avg_cust
FROM orders JOIN order_items USING (order_id)
GROUP BY 1;

-- создать представление, которое выводит среднюю сумму заказа
CREATE OR REPLACE VIEW avg_t AS  -- VIEW-2
SELECT AVG(quantity * unit_price) AS avg_total
FROM order_items;

-- вывести данные о клиентах, у которых средняя сумма заказа превышает общую среднюю сумму одного заказа
SELECT
  customer_id,
  c_name
FROM customers cst
WHERE (
  SELECT avg_cust
  FROM avg_c
  WHERE customer_id = cst.customer_id
) > (
  SELECT avg_total FROM avg_t
);
```

Если представления имеют смысл не только в контексте одного запроса и их можно переиспользовать для решения других задач, то их создание обосновано. Иначе логичнее решение построить на общих табличных выражениях (CTE)
```sql
WITH t1 AS ( -- CTE-1
  SELECT
    customer_id,
    avg(quantity * unit_price) AS avg_price_customer
  FROM order_items JOIN orders USING (order_id)
  GROUP BY 1
),
t2 AS ( -- CTE-2
  SELECT
    AVG(quantity * unit_price) AS total_avg_price
  FROM order_items
)
SELECT
  customer_id,
  c_name
FROM t1 JOIN customers USING (customer_id)
WHERE avg_price_customer > (
  SELECT total_avg_price FROM t2 -- t2.total_avg_price
)
ORDER BY customer_id;
```