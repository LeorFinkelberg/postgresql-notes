В процессе работы с базой данных возникает необходимость вносить изменения в существующие таблицы. Такими изменениями могут быть:
- добавление или удаление столбцов,
- изменение имени, типа и значения по умолчанию,
- добавление и удаление ограничений,
- удаление таблиц.

Для осуществления этих операций служит команда
```sql
ALTER TABLE {table_name}
{code_edit}
```

### Добавление и удаление столбцов

Для добавления нового столбца используется команда
```sql
ALTER TABLE {table_name} ADD COLUMN
({col_name} {col_type});
```

Пример
```sql
ALTER TABLE customers ADD COLUMN rating int4;
```

Для удаления существующих столбцов служит команда
```sql
ALTER TABLE {table_name} DROP COLUMN {col_name};
```

При применении этого оператора следует соблюдать следующие правила:
- одним оператором можно удалить только один столбец,
- нельзя удалить все столбцы в таблице.

### Изменение столбцов

Можно изменить имя столбцы, используя команду
```sql
ALTER TABLE {table_name}
RENAME COLUMN {old_name} TO {new_name};
```

Пример
```sql
ALTER TABLE customers
RENAME COLUMN rating TO rating_c;
```

Для изменения типа служит команда
```sql
ALTER TABLE {table_name}
ALTER COLUMN {table_name} TYPE {new_type};
```

Пример
```sql
ALTER TABLE customers
ALTER COLUMN rating_c TYPE smallint;
```

При использовании этого оператора следует соблюдать следующие правила: увеличивать число разрядов, числового столбца и ширину строки символов можно всегда, а уменьшать можно только до наибольшего значения, содержащегося в столбце.

Изменить значение по умолчанию можно командой
```sql
ALTER TABLE {table_name}
ALTER COLUMN {col_name} SET DEFAULT {value};
```

Пример
```sql
ALTER TABLE customers
ALTER COLUMN rating_c SET DEFAULT 1;
```

Изменение значения по умолчанию столбца влияет только на строки, которые будут добавлены позже, имеющиеся значения изменены не будут.

### Изменение ограничений

Добавление ограничения
```sql
ALTER TABLE {table_name} ADD CONSTRAINT {constr_name} {const_text};
```

Пример
```sql
ALTER TABLE customers ADD CONSTRAINT customers_rating_ch CHECK((rating_c > 0) AND (rating_c <= 5));
```

Удаление ограничения
```sql
ALTER TABLE {table_name}
DROP CONSTRAINT {const_name};
```

### Удаление таблицы

Для удаления таблицы используется команда `DROP TABLE`. В результате выполнения этой команды из таблицы удаляются все данные, и описание таблицы удаляются из словаря данных.

Если удаляемая таблица связана с другими таблицами, в которых определены внешние ключи, ссылающиеся на столбцы удаляемой таблицы, то эта команда не будет выполнена. 

Для удаления таблиц с ограничениями целостности следует использовать команду
```sql
DROP TABLE {table_name} CASCADE;
```

При выполнении этой команды в связанных таблицах удаляются ограничения внешнего ключа.
### Получение информации о таблицах базы данных

База данных PostgreSQL предоставляет два вида набора таблиц и представлений, которые содержат метаинформацию об объектах базы данных:
- Системный каталог (`pg_catalog`) - представляет собой набор таблиц и представлений с описанием всех объектов СУБД.
- Информационная схема (`information_schema`) -- предназначена для представления метаданных в соответствии со стандартами SQL, но не отражает ряд специфических особенностей PostgreSQL.

### Представления

_Представлением_ называют сохраненный запрос, которому присваивается имя. Это имя может использоваться в качестве источника данных в других запросах.

Имя представления не должно совпадать с именем таблиц базы данных. Если в качестве источника данных указано имя представления, то СУБД выполняет содержащийся в нем запрос и возвращает результат его выполнения.

По логике использования _представления_ имеют много общего с _подпрограммами_. Если какую-либо обработку данных приходится использовать _многократно_ в различных запросах, то целесообразно реализовать ее в виде представления, и указывать его имя там, где это необходимо. Имена представлений можно указывать там, где можно указывать имена таблиц [[Литература#^af0aa6]]<c. 235>. 

Для создания представлений используется оператор `CREATE VIEW`
```sql
CREATE [OR REPLACE] [TEMP] [RECURSIVE] VIEW {view_name} [{list_of_cols}]
AS {query_text}
[WITH [CASCADE | LOCAL] CHECK OPTION]
```

Параметры этого оператора:
- `OR REPLACE`: если этот оператор указан, то при повторном выполнении ранее созданное представление будет перезаписано,
- `TEMP`: при наличии этого параметра будет создано временное представление. Временные представления автоматически удаляются в конце текущего сеанса. Существующие постоянные представления с тем же именем не видны текущему сеансу, пока существует временное представление,
- `RECURSIVE`: будет создано рекурсивное представление,
- `WITH [CASCADE | LOCAL] CHECK OPTION`: этот параметр управляет поведением представлений, используемых для изменения данных. Если этот параметр указан, то при выполнении операторов `INSERT` и `UPDATE` будет осуществляться проверка: новые строки должны удовлетворять условиям, заданным в представлении. Если эти условия не будут выполнены хотя бы для одной строки, то изменение будет отменено для всех строк.

### Представления

Представления позволяют:
- упростить создание сложных запросов, которые следует разделить на части, и реализовать каждую часть в виде представления,
- ограничить доступ пользователей к данным, создавая представления, которые содержат только те столбцы, доступ к которым разрешен.

Есть два типа представлений: простые и сложные. Простое представление -- это представление, которое использует данные только из одной таблицы, не содержит фунцкий или групп данных. Сложное представление -- это представление, которое использует данные из нескольких таблиц или содержит функции или группы данных.

В операторах изменения данных `INSERT`, `UPDATE`, `MERGE`, `DELETE` можно использовать только простые представления.

Создание представления, которое содержит данные о сотрудниках, зарплата которых больше 8000, но меньше 10000
```sql
CREATE OR REPLACE VIEW view_salary_10000 AS 
SELECT
  department_id,
  employee_id,
  first_name,
  last_name,
  salary
FROM employees
WHERE salary BETWEEN 8000 AND 10000
WITH CHECK OPTION; -- проверяется условие, описанное в WHERE
```

Создание сложного представления, которое возвращает `order_id` , `order_date` и `summa`
```sql
CREATE OR REPLACE VIEW order_summa(order_id, order_date, summa)
AS
SELECT
  order_id,
  order_date,
  SUM(quantity * unit_price)
FROM orders JOIN order_items USING (order_id)
GROUP BY 1, 2;
```

Вывести данные о клиентах, у которых средняя сумма заказа превышает общую среднюю сумму одного заказа
```sql
-- создать представление, которое выводит номера клиентов и среднюю сумму их заказов
CREATE OR REPLACE VIEW avg_c AS  -- VIEW-1
SELECT
  customer_id,
  AVG(quantity * unit_price) AS avg_cust
FROM orders JOIN order_items USING (order_id)
GROUP BY 1;

-- создать представление, которое выводит среднюю сумму заказа
CREATE OR REPLACE VIEW avg_t AS  -- VIEW-2
SELECT AVG(quantity * unit_price) AS avg_total
FROM order_items;

-- вывести данные о клиентах, у которых средняя сумма заказа превышает общую среднюю сумму одного заказа
SELECT
  customer_id,
  c_name
FROM customers cst
WHERE (
  SELECT avg_cust
  FROM avg_c
  WHERE customer_id = cst.customer_id
) > (
  SELECT avg_total FROM avg_t
);
```

Если представления имеют смысл не только в контексте одного запроса и их можно переиспользовать для решения других задач, то их создание обосновано. Иначе логичнее решение построить на общих табличных выражениях (CTE)
```sql
WITH t1 AS ( -- CTE-1
  SELECT
    customer_id,
    avg(quantity * unit_price) AS avg_price_customer
  FROM order_items JOIN orders USING (order_id)
  GROUP BY 1
),
t2 AS ( -- CTE-2
  SELECT
    AVG(quantity * unit_price) AS total_avg_price
  FROM order_items
)
SELECT
  customer_id,
  c_name
FROM t1 JOIN customers USING (customer_id)
WHERE avg_price_customer > (
  SELECT total_avg_price FROM t2 -- t2.total_avg_price
)
ORDER BY customer_id;
```

### Последовательности

Последовательность является объектом базы данных, который используется для того, чтобы генерировать последовательные значения целых чисел.

Значения элементов последовательности генерируются независимо от таблиц, поэтому одна последовательность может использоваться для нескольких таблиц. Хотя такая возможность имеется, в большинстве случаев лучше использовать отдельную последовательность для каждого столбца, значения которому будут присваиваться при помощи последовательности.

Для создания последовательности используется оператор `CREATE SEQUENCE`, который имеет следующий синтаксис
```sql
CREATE [TEMP] SEQUENCE [IF NOT EXISTS]
{name}
[AS date_type]
[START WITH start] [CACHE cache] [CYCLE]
[INCREMENT [BY] increment]
[MINVALUE minvalue] | NO MINVALUE]
[MAXVALUE maxvalue] | NO MAXVALUE]
[OWNED BY {table_name.column_name}]
```

Рассмотрим параметры этого оператора:
- `TEMP`: при наличии этого параметра последовательность создается только для этого сеанса и автоматически удаляется при выходе из него. Существующие постоянные последовательности с тем же именем не видны (в этом сеансе), пока существует временная последовательность.
- `IF NOT EXISTS`: если этот параметр указан, то не будет возникать ошибка, если последовательность с тем же именем уже существует. Оператор создания последовательности не будет выполнен,
- `NAME`: имя последовательности.
- `DATE_TYPE`: определяет тип данных последовательности. Допустимыми типами являютстя `smallint`, `integer` и `bigint`. По умолчанию используется `bigint`.
- `START`: начальное значение, генерируемое последовательно. Значение по умолчанию равно `minvalue` для восходящих последовательностей и `maxvalue` для нисходящих.
- `CACHE`: указывает, сколько порядковых номеров должно быть предварительно сформировано и сохранено в оперативной памяти для более быстрого доступа.
- `CYCLE`: при использовании этого параметра последовательность будет продолжать генерацию значений после достижения максимального или минимального значения. Когда возрастающая последовательность достигнет своего максимума, то следующее значение будет равно минимальному значению последовательности;
  - `increment`: шаг изменения значений последовательности, может быть отрицательным числом, значение по умолчанию равно 1;
  - `minvalue`: минимальное значение, генерируемое последовательностью;
  - `maxvalue`: максимальное значение, генерируемое последовательностью;
- `OWNED BY {table_name.column_name}`: связывает последовательность с определенным столбцом таблицы, так что, если этот столбец (или вся его таблица) будет удален, последовательность также будет автоматически удалена.

#### Функции для работы с последовательностями

Для работы с последовательностями можно использовать следующие функции:
- `NEXTVAL('{seq_name}')`: формирует следующее значение последовательности и возвращает это значение. При первом обращении возвращает значение `start`.
 - `CURRVAL('{seq_name}')`: возвращает текущее значение последовательности.
 - `SETVAL('{seq_name}', new_cur)`:  задает новое текущее значение последовательности, равное `new_cur`. Функция `NEXTVAL()` вернет значение `new_cur + increment`.

Создание последовательности `EMPLOYEES_ID_SEQ`
```sql
CREATE SEQUENCE employees_id_seq
START WITH 210
INCREMENT BY 1
MAXVALUE 5000;
```

Создание последовательности `DEPARTMENTS_ID_SEQ`
```sql
CREATE SEQUENCE departments_id_seq
START WITH 300
INCREMENT BY 10
MAXVALUE 1000;
```

Перед вызовом функции `CURRVAL()` необходимо вызывать `NEXTVAL()`! В простейшем случае получается так
```sql
SELECT NEXTVAL('department_id_seq');
```

Ввод данных о новом отделе
```sql
INSERT INTO departments(department_id, depratment_name, manager_id, location_id)
VALUES (NEXTVAL('department_id_seq'), 'Logistics', 121, 1700);
```

Ввод данных о новом сотруднике нового отдела
```sql
INSERT INTO employees(employee_id, department_id, first_name, last_name, hire_date) VALUES (NEXTVAL('employees_id_seq'), CURRVAL('department_id_seq'), 'John', 'Connor', DEFAULT)
RETURNING employee_id, depratment_id, first_name, last_name, hire_date;
```

Перевод сотрудника в новый отдел
```sql
UPDATE employees
SET department_id = CURRVAL('department_id_seq')
WHERE employee_id = 121;
```

Узнать текущее значение последовательности можно так
```sql
SELECT CURRVAL('{seq_name}');
```

Вывод информации о сотрудниках нового отедела
```sql
SELECT
  employee_id,
  department_id,
  first_name,
  last_name,
  job_id,
  hire_date
FROM employees
WHERE department_id = CURRVAL('department_id_seq');
```

Параметры последовательности можно изменить командой `ALTER SEQUENCE`. Параметры последовательности, не указанные в команде `ALTER SEQUENCE`, остаются без изменений.

Пример
```sql
ALTER SEQUENCE employees_id_seq
INCREMENT by 2;
```

Ограничения на изменение последовательностей:
- нельзя изменить начальное значение последовательности,
- минимальное значение не может быть больше текущего значения,
- максимальное значение не может быть меньше текущего значения.

Удаление последовательности
```sql
DROP SEQUENCE seq_name;
```

### Индексы

Индекс представляет собой отсортированные (упорядоченные) значения столбца, для которого он создан. Это позволяет быстро находить связанные с ним строки таблицы и сокращать до минимума число операций обращения к магнитному диску или другому устройству, на котором храняться таблицы базы данных.

Индексы автоматически создаются сервером при определении первичного ключа или создания ограничения на уникальность значений. При выполнении операторов изменения данных (`INSERT`, `UPDATE`, `DELETE`) сервер автоматически обновляет индексы. Обновление индексов требует времени, поэтому время выполнения операторов изменения данных возрастает.

Если функция, на базе которой построен индекс, будет возвращать значения `NULL`, то этот индекс не будет использоваться или будет работать неэффективно. Для того чтобы этого избежать, следует добавить условие `IS NOT NULL` в предложение `WHERE`.

Исключение значений `NULL` при использовании индекса на базе функции
```sql
SELECT
  employee_id,
  first_name,
  last_name
FROM employees
WHERE UPPER(lsat_name) IS NOT NULL AND UPPER(last_name) = 'KING';
```

Можно создавать индекс по нескольким столбцам
```sql
SELECT INDEX first_last_name_idx
ON employees(last_name, first_name);
```

На первом месте следует указать столбец, значения которого повторяются реже. После создания такого индекса время поиска сократиться как при поиске по столбцу `last_name`, так и по столбцу `first_name`. 

Пример
```sql
CREATE INDEX first_last_name_idx
ON employees((first_name || ' ' || last_name));

SELECT
  employee_id,
  first_name,
  last_name
FROM employees
WHERE (first_name || ' ' || last_name) = 'Janette King';
```

Можно перестроить индексы и сделать их более компактными, а потому и более эффективными, периодически применяя команду `REINDEX`
```sql
REINDEX INDEX upper_last_name_idx;
```