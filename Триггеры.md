Триггер -- это спецификация, согласно которой СУБД должна автоматически выполнять определенную _триггерную функцию_.

Различают _DML-триггеры_ (реагирует на DML-операторы: `INSERT`, `UPDATE`, `DELETE`) и _событийные триггеры_.

NB: наличие большого количества триггеров ==может увеличить время выполнения операций с базой данных==. Также ==могут возникнуть сложные проблемы==, связанные с взаимным влиянием триггеров друг на друга. Поэтому ==триггеры следует использовать только тогда, когда проблема, решаемая с помощью триггера, является важной и ее нельзя решить, используя другие средства PL/pgSQL==.
### DML-триггеры

Этот тип триггеров запускается при выполнении DML-операторов (`INSERT`, `UPDATE`, `DELETE`) для определенной таблицы или представления базы данных. Это наиболее распространенный тип триггеров, который используется разработчиками, другие типы триггеров используют в основном администраторы базы данных.

Оператор создания DML-триггера
```sql
CREATE [OR REPLACE] TRIGGER {trigger_name}
{time_to_trigger} {event} ON {table_name | view}
[FOR EACH ROW]
[WHEN {cond}]
EXECUTE {FUNCTION | PROCEDURE} {name};
```

Если фраза `FOR EACH ROW` отсутствует, то такой триггер называется _операторным триггером_, и он будет срабатывать один раз. При наличии фразы `FOR EACH ROW` триггер называется _строковым триггером_, и он будет выполняться для каждой строки, к которой будет применен оператор DML.
### Триггерные функции

_Триггерные функции_ определяют действия, которые должны быть выполнены при срабатывании триггера. Триггерная функция должна быть создана до того, как будет создан триггер.

Триггерная функция возвращает либо `NULL`, либо строку таблицы, для которой сработал триггер. Триггерные функции операторных триггеров всегда должны возвращать `NULL` [[Литература#^af0aa6]]<c. 415>.

Важной функцией триггеров является реализация ограничений и безнес-правил, которые действуют в предметной области. Следует иметь в виду, что ограничения, которые обеспечиваются использованием триггеров, довольно сложно обойти.

Пример. Создадим триггер для реализации следующего ограничения: нельзя добавлять новый заказ для клиента, у которого сумма заказов, находящихся в состоянии ожидания, превышает его кредитный лимит. Для упрощения кода этого триггера будем использовать функцию `f_credit_limit(i)`, которая возвращает кредитный лимит клиента, и функцию `f_orders_sum(i, j)`, которая возвращает общую сумму заказов клиента `i`, находящихся в состоянии `j`. 

Создание функции `f_credit_limit`
```sql
CREATE OR REPLACE FUNCTION f_credit_limit(p_customer_id INTEGER)
RETURNS NUMERIC(10, 2)
AS $$
DECLARE
   v_credit_limit NUMERIC(10, 2);
BEGIN
  SELECT credit_limit INTO v_credit_limit
  FROM customers
  WHERE customer_id = p_customer_id;
  RETURN v_credit_limit;
END $$ LANGUAGE plpgsql;
```

Создание функции `f_orders_sum`
```sql
CREATE OR REPLACE FUNCTION f_orders_sum(
  p_customer_id INTEGER,
  p_status VARCHAR
)
RETURNS NUMERIC(10, 2)
AS $$
DECLARE
  v_orders_sum NUMERIC(10, 2);
BEGIN
  SELECT
    SUM(quantity * unit_price) INTO v_orders_sum
  FROM orders JOIN order_items USING (order_id)
  WHERE customer_id = p_customer_id AND status = p_status;
  RETURN v_orders_sum;
END $$ LANGUAGE plpgsql;
```

Создание триггерной функции `f_ord_limit()`, которая обеспечивает выполнение рассматриваемого бизнес-правила
```sql
CREATE OR REPLACE FUNCTION f_ord_limit()
RETURNS TRIGGER
AS $$
BEGIN
  -- `NEW` - это специальная переменная триггерной функции
  IF f_orders_sum(NEW.customer_id, NEW.status) > f_credit_limit(NEW.customer_id)
  THEN
    RAISE EXCEPTION 'Операция отклонена, так как превышен кредитный лимит клиента';
  END IF;
  RETURN NEW;
END $$ LANGUAGE plpgsql;
```
Здесь `NEW` -- это специальная переменная триггерной функции (подробнее в [[Литература#^af0aa6]]<c. 422>).
Создадим строчный триггер, который активирует функцию `f_ord_limit()`
```sql
CREATE OR REPLACE TRIGGER tr_ord_limit
BEFORE INSERT ON orders
FOR EACH ROW  -- поэтому триггер и строчный, а не операторный
EXECUTE FUNCTION f_ord_limit();
```

То есть при попытке вставить новую запись в таблицу `orders` для каждой строки (для каждой операции вставки) будет вызываться триггерная функция `f_ord_limit()`, которая через специальную переменную `NEW` получает доступ к вставляемой записи, извлекает значение атрибутов `NEW.customer_id`, `NEW.status` и пр., проверяет условие и либо возбуждает исключение, либо просто возвращает эту новую запись.
### Триггеры для оператора MERGE

В качестве события, которое активирует триггер, не может быть указан оператор `MERGE`. Но при выполнении этого оператора будут выполнение либо операторы `UPDATE` и `INSERT`, либо операторы `DELETE` и `INSERT`. Поэтому, если у триггера указаны события `INSERT OR UPDATE OR DELETE`, то он будет активирован и при выполнении оператора `MERGE`.

### Управление триггерами

При необходимости DML-триггеры можно отключить
```sql
ALTER TABLE {table_name}
DISABLE TIGGER {trigger_name} | ALL;
```

Можно отключить определенный триггер, указав его имя, или все триггеры, связанные с таблицей, указав ключевое слово `ALL`.

Для отключения событийных триггеров используется команда
```sql
ALTER EVENT TRIGGER {trigger_name} DISABLE;
```
После отключения триггер остается в базе данных. Однако если происходит событие, связанное с триггером, отключенный триггер не сравботает.

Триггеры, которые были отключены, можно включить
```sql
ALTER TABLE {table_name}
ENABLE TRIGGER {trigger_name} | ALL;
```

Для включения триггеров событий используется команда
```sql
ALTER EVENT TRIGGER {trigger_name} ENABLE;
```

Для удаления DML-триггеров
```sql
DROP TRIGGER [IF EXISTS] {trigger_name}
ON {table_name} [CASCADE | RESTRICT]
```

Для удаления триггеров событий используется команда
```sql
DROP EVENT TRIGGER [IF EXISTS] {trigger_name} [CASCADE | RESTRICT]
```

Если указать `IF EXISTS`, то не будет возникать ошибка при удалении несуществующего триггера. Если указать `CASCADE`, то будут удалены объекты, которые зависят от триггера. По умолчанию используется `RESTRICT`. В этом случае удаление триггера будет отменено, если от него зависят другие объекты.
